{"version":3,"file":"dom.js","sourceRoot":"","sources":["../src/lib/dom.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAUH;;GAEG;AACH,MAAM,CAAC,MAAM,YAAY,GAAG,MAAM,CAAC,cAAc,KAAK,SAAS;IAC1D,MAAM,CAAC,cAAoC,CAAC,yBAAyB;QAClE,SAAS,CAAC;AAElB;;;;;GAKG;AACH,MAAM,CAAC,MAAM,aAAa,GACtB,CAAC,SAAe,EACf,KAAgB,EAChB,MAAiB,IAAI,EACrB,SAAoB,IAAI,EAAQ,EAAE;IACjC,IAAI,IAAI,GAAG,KAAK,CAAC;IACjB,OAAO,IAAI,KAAK,GAAG,EAAE;QACnB,MAAM,CAAC,GAAG,IAAK,CAAC,WAAW,CAAC;QAC5B,SAAS,CAAC,YAAY,CAAC,IAAK,EAAE,MAAc,CAAC,CAAC;QAC9C,IAAI,GAAG,CAAC,CAAC;KACV;AACH,CAAC,CAAC;AAEN;;;GAGG;AACH,MAAM,CAAC,MAAM,WAAW,GACpB,CAAC,SAAe,EAAE,SAAoB,EAAE,UAAqB,IAAI,EACxD,EAAE;IACL,IAAI,IAAI,GAAG,SAAS,CAAC;IACrB,OAAO,IAAI,KAAK,OAAO,EAAE;QACvB,MAAM,CAAC,GAAG,IAAK,CAAC,WAAW,CAAC;QAC5B,SAAS,CAAC,WAAW,CAAC,IAAK,CAAC,CAAC;QAC7B,IAAI,GAAG,CAAC,CAAC;KACV;AACH,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * @module lit-html\n */\n\ninterface MaybePolyfilledCe extends CustomElementRegistry {\n  polyfillWrapFlushCallback?: object;\n}\n\n/**\n * True if the custom elements polyfill is in use.\n */\nexport const isCEPolyfill = window.customElements !== undefined &&\n    (window.customElements as MaybePolyfilledCe).polyfillWrapFlushCallback !==\n        undefined;\n\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes =\n    (container: Node,\n     start: Node|null,\n     end: Node|null = null,\n     before: Node|null = null): void => {\n      let node = start;\n      while (node !== end) {\n        const n = node!.nextSibling;\n        container.insertBefore(node!, before as Node);\n        node = n;\n      }\n    };\n\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes =\n    (container: Node, startNode: Node|null, endNode: Node|null = null):\n        void => {\n          let node = startNode;\n          while (node !== endNode) {\n            const n = node!.nextSibling;\n            container.removeChild(node!);\n            node = n;\n          }\n        };\n"]}