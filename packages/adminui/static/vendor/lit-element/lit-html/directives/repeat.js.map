{"version":3,"file":"repeat.js","sourceRoot":"","sources":["../src/directives/repeat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {DirectiveFn} from '../lib/directive.js';\nimport {createMarker, directive, NodePart, Part, removeNodes, reparentNodes} from '../lit-html.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart =\n    (containerPart: NodePart, beforePart?: NodePart): NodePart => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = beforePart === undefined ? containerPart.endNode :\n                                                    beforePart.startNode;\n      const startNode = container.insertBefore(createMarker(), beforeNode);\n      container.insertBefore(createMarker(), beforeNode);\n      const newPart = new NodePart(containerPart.options);\n      newPart.insertAfterNode(startNode);\n      return newPart;\n    };\n\nconst updatePart = (part: NodePart, value: unknown) => {\n  part.setValue(value);\n  part.commit();\n  return part;\n};\n\nconst insertPartBefore =\n    (containerPart: NodePart, part: NodePart, ref?: NodePart) => {\n      const container = containerPart.startNode.parentNode as Node;\n      const beforeNode = ref ? ref.startNode : containerPart.endNode;\n      const endNode = part.endNode.nextSibling;\n      if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n      }\n    };\n\nconst removePart = (part: NodePart) => {\n  removeNodes(\n      part.startNode.parentNode!, part.startNode, part.endNode.nextSibling);\n};\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\n// Stores previous ordered list of parts and map of key to index\nconst partListCache = new WeakMap<NodePart, (NodePart | null)[]>();\nconst keyListCache = new WeakMap<NodePart, unknown[]>();\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * amd removals.\n *\n * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat =\n    directive(\n        <T>(items: Iterable<T>,\n            keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n            template?: ItemTemplate<T>):\n            DirectiveFn => {\n              let keyFn: KeyFn<T>;\n              if (template === undefined) {\n                template = keyFnOrTemplate;\n              } else if (keyFnOrTemplate !== undefined) {\n                keyFn = keyFnOrTemplate as KeyFn<T>;\n              }\n\n              return (containerPart: Part): void => {\n                if (!(containerPart instanceof NodePart)) {\n                  throw new Error('repeat can only be used in text bindings');\n                }\n                // Old part & key lists are retrieved from the last update\n                // (associated with the part for this instance of the directive)\n                const oldParts = partListCache.get(containerPart) || [];\n                const oldKeys = keyListCache.get(containerPart) || [];\n\n                // New part list will be built up as we go (either reused from\n                // old parts or created for new keys in this update). This is\n                // saved in the above cache at the end of the update.\n                const newParts: NodePart[] = [];\n\n                // New value list is eagerly generated from items along with a\n                // parallel array indicating its key.\n                const newValues: unknown[] = [];\n                const newKeys: unknown[] = [];\n                let index = 0;\n                for (const item of items) {\n                  newKeys[index] = keyFn ? keyFn(item, index) : index;\n                  newValues[index] = template !(item, index);\n                  index++;\n                }\n\n                // Maps from key to index for current and previous update; these\n                // are generated lazily only when needed as a performance\n                // optimization, since they are only required for multiple\n                // non-contiguous changes in the list, which are less common.\n                let newKeyToIndexMap!: Map<unknown, number>;\n                let oldKeyToIndexMap!: Map<unknown, number>;\n\n                // Head and tail pointers to old parts and new values\n                let oldHead = 0;\n                let oldTail = oldParts.length - 1;\n                let newHead = 0;\n                let newTail = newValues.length - 1;\n\n                // Overview of O(n) reconciliation algorithm (general approach\n                // based on ideas found in ivi, vue, snabbdom, etc.):\n                //\n                // * We start with the list of old parts and new values (and\n                // arrays of\n                //   their respective keys), head/tail pointers into each, and\n                //   we build up the new list of parts by updating (and when\n                //   needed, moving) old parts or creating new ones. The initial\n                //   scenario might look like this (for brevity of the diagrams,\n                //   the numbers in the array reflect keys associated with the\n                //   old parts or new values, although keys and parts/values are\n                //   actually stored in parallel arrays indexed using the same\n                //   head/tail pointers):\n                //\n                //      oldHead v                 v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n                //   item order\n                //      newHead ^                 ^ newTail\n                //\n                // * Iterate old & new lists from both sides, updating,\n                // swapping, or\n                //   removing parts at the head/tail locations until neither\n                //   head nor tail can move.\n                //\n                // * Example below: keys at head pointers match, so update old\n                // part 0 in-\n                //   place (no need to move it) and record part 0 in the\n                //   `newParts` list. The last thing we do is advance the\n                //   `oldHead` and `newHead` pointers (will be reflected in the\n                //   next diagram).\n                //\n                //      oldHead v                 v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n                //   and newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldHead\n                //   & newHead\n                //      newHead ^                 ^ newTail\n                //\n                // * Example below: head pointers don't match, but tail pointers\n                // do, so\n                //   update part 6 in place (no need to move it), and record\n                //   part 6 in the `newParts` list. Last, advance the `oldTail`\n                //   and `oldHead` pointers.\n                //\n                //         oldHead v              v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n                //   and newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldTail\n                //   & newTail\n                //         newHead ^              ^ newTail\n                //\n                // * If neither head nor tail match; next check if one of the\n                // old head/tail\n                //   items was removed. We first need to generate the reverse\n                //   map of new keys to index (`newKeyToIndexMap`), which is\n                //   done once lazily as a performance optimization, since we\n                //   only hit this case if multiple non-contiguous changes were\n                //   made. Note that for contiguous removal anywhere in the\n                //   list, the head and tails would advance from either end and\n                //   pass each other before we get to this case and removals\n                //   would be handled in the final while loop without needing to\n                //   generate the map.\n                //\n                // * Example below: The key at `oldTail` was removed (no longer\n                // in the\n                //   `newKeyToIndexMap`), so remove that part from the DOM and\n                //   advance just the `oldTail` pointer.\n                //\n                //         oldHead v           v oldTail\n                //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n                //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map; remove\n                //   5 and newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance oldTail\n                //         newHead ^           ^ newTail\n                //\n                // * Once head and tail cannot move, any mismatches are due to\n                // either new or\n                //   moved items; if a new key is in the previous \"old key to\n                //   old index\" map, move the old part to the new location,\n                //   otherwise create and insert a new part. Note that when\n                //   moving an old part we null its position in the oldParts\n                //   array if it lies between the head and tail so we know to\n                //   skip it when the pointers get there.\n                //\n                // * Example below: neither head nor tail match, and neither\n                // were removed;\n                //   so find the `newHead` key in the `oldKeyToIndexMap`, and\n                //   move that old part's DOM into the next head position\n                //   (before `oldParts[oldHead]`). Last, null the part in the\n                //   `oldPart` array since it was somewhere in the remaining\n                //   oldParts still to be scanned (between the head and tail\n                //   pointers) so that we know to skip that old part on future\n                //   iterations.\n                //\n                //         oldHead v        v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck; update & move 2\n                //   into place newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance\n                //   newHead\n                //         newHead ^           ^ newTail\n                //\n                // * Note that for moves/insertions like the one above, a part\n                // inserted at\n                //   the head pointer is inserted before the current\n                //   `oldParts[oldHead]`, and a part inserted at the tail\n                //   pointer is inserted before `newParts[newTail+1]`. The\n                //   seeming asymmetry lies in the fact that new parts are moved\n                //   into place outside in, so to the right of the head pointer\n                //   are old parts, and to the right of the tail pointer are new\n                //   parts.\n                //\n                // * We always restart back from the top of the algorithm,\n                // allowing matching\n                //   and simple updates in place to continue...\n                //\n                // * Example below: the head pointers once again match, so\n                // simply update\n                //   part 1 and record it in the `newParts` array.  Last,\n                //   advance both head pointers.\n                //\n                //         oldHead v        v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched; update 1\n                //   and newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldHead\n                //   & newHead\n                //            newHead ^        ^ newTail\n                //\n                // * As mentioned above, items that were moved as a result of\n                // being stuck\n                //   (the final else clause in the code below) are marked with\n                //   null, so we always advance old pointers over these so we're\n                //   comparing the next actual old value on either end.\n                //\n                // * Example below: `oldHead` is null (already placed in\n                // newParts), so\n                //   advance `oldHead`.\n                //\n                //            oldHead v     v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6] // old head already used;\n                //   advance newParts: [0, 2, 1,  ,  ,  , 6] // oldHead newKeys:\n                //   [0, 2, 1, 4, 3, 7, 6]\n                //               newHead ^     ^ newTail\n                //\n                // * Note it's not critical to mark old parts as null when they\n                // are moved\n                //   from head to tail or tail to head, since they will be\n                //   outside the pointer range and never visited again.\n                //\n                // * Example below: Here the old tail key matches the new head\n                // key, so\n                //   the part at the `oldTail` position and move its DOM to the\n                //   new head position (before `oldParts[oldHead]`). Last,\n                //   advance `oldTail` and `newHead` pointers.\n                //\n                //               oldHead v  v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n                //   head: update newKeys:  [0, 2, 1, 4, 3, 7, 6]   & move 4,\n                //   advance oldTail & newHead\n                //               newHead ^     ^ newTail\n                //\n                // * Example below: Old and new head keys match, so update the\n                // old head\n                //   part in place, and advance the `oldHead` and `newHead`\n                //   pointers.\n                //\n                //               oldHead v oldTail\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n                //   and advance newKeys:  [0, 2, 1, 4, 3, 7, 6]    oldHead &\n                //   newHead\n                //                  newHead ^  ^ newTail\n                //\n                // * Once the new or old pointers move past each other then all\n                // we have\n                //   left is additions (if old list exhausted) or removals (if\n                //   new list exhausted). Those are handled in the final while\n                //   loops at the end.\n                //\n                // * Example below: `oldHead` exceeded `oldTail`, so we're done\n                // with the\n                //   main loop.  Create the remaining part and insert it at the\n                //   new head position, and the update is complete.\n                //\n                //                   (oldHead > oldTail)\n                //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n                //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n                //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n                //                     newHead ^ newTail\n                //\n                // * Note that the order of the if/else clauses is not important\n                // to the\n                //   algorithm, as long as the null checks come first (to ensure\n                //   we're always working on valid old parts) and that the final\n                //   else clause comes last (since that's where the expensive\n                //   moves occur). The order of remaining clauses is is just a\n                //   simple guess at which cases will be most common.\n                //\n                // * TODO(kschaaf) Note, we could calculate the longest\n                // increasing\n                //   subsequence (LIS) of old items in new position, and only\n                //   move those not in the LIS set. However that costs O(nlogn)\n                //   time and adds a bit more code, and only helps make rare\n                //   types of mutations require fewer moves. The above handles\n                //   removes, adds, reversal, swaps, and single moves of\n                //   contiguous items in linear time, in the minimum number of\n                //   moves. As the number of multiple moves where LIS might help\n                //   approaches a random shuffle, the LIS optimization becomes\n                //   less helpful, so it seems not worth the code at this point.\n                //   Could reconsider if a compelling case arises.\n\n                while (oldHead <= oldTail && newHead <= newTail) {\n                  if (oldParts[oldHead] === null) {\n                    // `null` means old part at head has already been used\n                    // below; skip\n                    oldHead++;\n                  } else if (oldParts[oldTail] === null) {\n                    // `null` means old part at tail has already been used\n                    // below; skip\n                    oldTail--;\n                  } else if (oldKeys[oldHead] === newKeys[newHead]) {\n                    // Old head matches new head; update in place\n                    newParts[newHead] =\n                        updatePart(oldParts[oldHead]!, newValues[newHead]);\n                    oldHead++;\n                    newHead++;\n                  } else if (oldKeys[oldTail] === newKeys[newTail]) {\n                    // Old tail matches new tail; update in place\n                    newParts[newTail] =\n                        updatePart(oldParts[oldTail]!, newValues[newTail]);\n                    oldTail--;\n                    newTail--;\n                  } else if (oldKeys[oldHead] === newKeys[newTail]) {\n                    // Old head matches new tail; update and move to new tail\n                    newParts[newTail] =\n                        updatePart(oldParts[oldHead]!, newValues[newTail]);\n                    insertPartBefore(\n                        containerPart,\n                        oldParts[oldHead]!,\n                        newParts[newTail + 1]);\n                    oldHead++;\n                    newTail--;\n                  } else if (oldKeys[oldTail] === newKeys[newHead]) {\n                    // Old tail matches new head; update and move to new head\n                    newParts[newHead] =\n                        updatePart(oldParts[oldTail]!, newValues[newHead]);\n                    insertPartBefore(\n                        containerPart, oldParts[oldTail]!, oldParts[oldHead]!);\n                    oldTail--;\n                    newHead++;\n                  } else {\n                    if (newKeyToIndexMap === undefined) {\n                      // Lazily generate key-to-index maps, used for removals &\n                      // moves below\n                      newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n                      oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n                    }\n                    if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n                      // Old head is no longer in new list; remove\n                      removePart(oldParts[oldHead]!);\n                      oldHead++;\n                    } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n                      // Old tail is no longer in new list; remove\n                      removePart(oldParts[oldTail]!);\n                      oldTail--;\n                    } else {\n                      // Any mismatches at this point are due to additions or\n                      // moves; see if we have an old part we can reuse and move\n                      // into place\n                      const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n                      const oldPart =\n                          oldIndex !== undefined ? oldParts[oldIndex] : null;\n                      if (oldPart === null) {\n                        // No old part for this value; create a new one and\n                        // insert it\n                        const newPart = createAndInsertPart(\n                            containerPart, oldParts[oldHead]!);\n                        updatePart(newPart, newValues[newHead]);\n                        newParts[newHead] = newPart;\n                      } else {\n                        // Reuse old part\n                        newParts[newHead] =\n                            updatePart(oldPart, newValues[newHead]);\n                        insertPartBefore(\n                            containerPart, oldPart, oldParts[oldHead]!);\n                        // This marks the old part as having been used, so that\n                        // it will be skipped in the first two checks above\n                        oldParts[oldIndex as number] = null;\n                      }\n                      newHead++;\n                    }\n                  }\n                }\n                // Add parts for any remaining new values\n                while (newHead <= newTail) {\n                  // For all remaining additions, we insert before last new\n                  // tail, since old pointers are no longer valid\n                  const newPart = createAndInsertPart(\n                      containerPart, newParts[newTail + 1]!);\n                  updatePart(newPart, newValues[newHead]);\n                  newParts[newHead++] = newPart;\n                }\n                // Remove any remaining unused old parts\n                while (oldHead <= oldTail) {\n                  const oldPart = oldParts[oldHead++];\n                  if (oldPart !== null) {\n                    removePart(oldPart);\n                  }\n                }\n                // Save order of new parts for next round\n                partListCache.set(containerPart, newParts);\n                keyListCache.set(containerPart, newKeys);\n              };\n            }) as\n    <T>(items: Iterable<T>,\n        keyFnOrTemplate: KeyFn<T>|ItemTemplate<T>,\n        template?: ItemTemplate<T>) => DirectiveFn;\n"]}